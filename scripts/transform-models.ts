// scripts/transform-models.ts
import { execSync } from 'node:child_process';
import {
	copyFileSync,
	existsSync,
	mkdirSync,
	readdirSync,
	unlinkSync,
	writeFileSync,
	readFileSync
} from 'node:fs';
import { join, resolve } from 'node:path';
import { exit } from 'node:process';

const configuration = {
	sourceDir: resolve('static/models'),
	targetDir: resolve('src/lib/models'),
	overwrite: true,
	root: '/models/',
	tagComponents: true,
	generateIndex: true,

	// ‚úÖ Transform options
	transform: {
		enabled: false,
		resolution: 1024,
		draco: null, // e.g. 'meshopt' or 'draco'
		simplify: {
			enabled: false,
			weld: 0.0001,
			ratio: 0.75,
			error: 0.001
		}
	}
} as const;


mkdirSync(configuration.targetDir, { recursive: true });
if (!existsSync(configuration.sourceDir)) throw new Error(`Source dir not found.`);

const gltfFiles = readdirSync(configuration.sourceDir).filter((file) =>
	(file.endsWith('.glb') || file.endsWith('.gltf')) &&
	!file.endsWith('-transformed.gltf') &&
	!file.endsWith('-transformed.glb')
);

if (gltfFiles.length === 0) {
	console.log('üõë No new GLTF/GLB files to process.');
	exit();
}

gltfFiles.forEach((file) => {
	const path = join(configuration.sourceDir, file);
const args: string[] = [];

if (configuration.root) args.push(`--root ${configuration.root}`);
args.push('--types', '--keepnames', '--isolated');
//args.push(`--printwidth 120`, `--precision 2`);

if (configuration.transform.enabled) {
	args.push('--transform');
	//args.push(`--resolution ${configuration.transform.resolution}`);

	// if (configuration.transform.simplify.enabled) {
	// 	args.push('--simplify');
	// 	args.push(`--weld ${configuration.transform.simplify.weld}`);
	// 	args.push(`--ratio ${configuration.transform.simplify.ratio}`);
	// 	args.push(`--error ${configuration.transform.simplify.error}`);
	// }

	// if (configuration.transform.draco) {
	// 	args.push(`--draco ${configuration.transform.draco}`);
	// }
}


	const cmd = `npx @threlte/gltf@next ${path} ${args.join(' ')}`;
	try {
		console.log(`üõ†Ô∏è Transforming ${file}...`);
		execSync(cmd, { cwd: configuration.sourceDir });
	} catch (err) {
		console.error(`‚ùå Error transforming ${file}`, err);
	}
});

const svelteFiles = readdirSync(configuration.sourceDir).filter((f) => f.endsWith('.svelte'));

svelteFiles.forEach((file) => {
	const srcPath = join(configuration.sourceDir, file);
	const destPath = join(configuration.targetDir, file);

	if (!configuration.overwrite && existsSync(destPath)) return;

	copyFileSync(srcPath, destPath);
	unlinkSync(srcPath);

	// Optional: add a generated tag to the top of the file
	if (configuration.tagComponents) {
		const original = readFileSync(destPath, 'utf-8');
		const tagged = `<!-- AUTO-GENERATED by transform-models.ts -->\n${original}`;
		writeFileSync(destPath, tagged);
	}
	console.log(`üì¶ Copied ${file} to /models`);
});

// Optional: generate index.ts
if (configuration.generateIndex) {
	const entries = readdirSync(configuration.targetDir)
		.filter(f => f.endsWith('.svelte'))
		.map(f => `export { default as ${f.replace('.svelte', '')} } from './${f}'`);

	writeFileSync(join(configuration.targetDir, 'index.ts'), entries.join('\n'));
	console.log(`üìÅ index.ts updated with ${entries.length} exports`);
}
